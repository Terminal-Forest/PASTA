---
title: "Using PASTA for Analyzing APA in PBMCs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using PASTA for Analyzing APA in PBMCs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
#remotes::install_github(repo = "satijalab/PASTA")
devtools::load_all()
library(PASTA)
```

## Map Azimuth to RNA
First, you can quantify RNA and map to azimuth in the standard way. 
```{r read_in_seurat_object}
pbmc <- readRDS(file = "/brahms/shared/PASTA/pbmc.rds")
projected.umap <- readRDS('/brahms/shared/PASTA/umap_pbmcs.Rds')
pbmc <- pbmc[, Cells(projected.umap)]
pbmc[['umap']] <- projected.umap
predictions <- read.delim('/brahms/shared/PASTA/azimuth_pred_pbmcs.tsv', row.names = 1)
pbmc <- AddMetaData(
  object = pbmc,
  metadata = predictions)
DimPlot(pbmc, group.by = 'predicted.celltype.l2', label = T) + NoLegend()
```

## Make polyA assay

```{r load_polyA}
pA.count.file <- "/brahms/shared/PASTA/pA_counts.tab.gz"
peak.file <- "/brahms/shared/PASTA/pA_polyA_peaks.gff"
fragment.file <- "/brahms/shared/PASTA/10k_PBMC.blocks.sort.uniq.bed.gz"

pA.counts = ReadPolyApipe( counts.file = pA.count.file, 
                           peaks.file = peak.file, 
                           filter.chromosomes = TRUE,
                           min.features = 10, 
                           min.cells = 25)

#add gemgroup information to match cellranger output
colnames(pA.counts) <- paste0( colnames(pA.counts), '-1')

# create polyAsite.Assay
pA.assay = CreatePolyAsiteAssay(counts = pA.counts , genome = "hg38", fragments = fragment.file, validate.fragments = FALSE)
```

## Add polyA site assay to seurat object
```{r, include=FALSE}
# intersect cells between polyA assay and RNA assay 
cells = intersect( Cells(pbmc) , Cells(pA.assay))
pbmc = subset(pbmc, cells = cells)
pA.assay = subset(pA.assay, cells = cells)
pbmc[['pA']] <- pA.assay
```

## Annotate peaks 
```{r annotate}
# Annotate from EnsDB is done similarly to polyApipe
# In addition, we annotate tandem UTRs
gtf.file = '/brahms/shared/PASTA/GENCODE_hg38_v32_ensembl98.gtf'
BSgenome <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38

pbmc = AnnotatePASfromGTF(object = pbmc, assay = "pA", 
                           transcriptDetails = TRUE, SequenceAnalysis = FALSE, PAS_Types = FALSE,
                           genome = BSgenome, gtf.file = gtf.file,
                           pA_motif_max_position = 60, AAA_motif_min_position = 10,
                           polystretch_length = 10, max_mismatch = 1, 
                           hard_extension = 10, extension = 2000 )
```

## Calculate polyA site redundancies

