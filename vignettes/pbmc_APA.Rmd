---
title: "Using PASTA for Analyzing alternative polyadenylation in PBMCs"
output:
  html_document:
    theme: united
    df_print: kable
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE)
```

```{r setup}
#remotes::install_github(repo = "satijalab/PASTA")
#library(PASTA)
devtools::load_all()
```

## PBMC 10k Datasets 
We downloaded 10k human pbmcs available here: https://www.10xgenomics.com/resources/datasets/10k-human-pbmcs-3-v3-1-chromium-x-without-introns-3-1-high
For this analysis, you need the bam files to quantify polyA sites as well as the standard RNA counts matrix.

## Annotate Cells using RNA.
First, you can quantify RNA and create a seurat object. Then, annotate cells by mapping to azimuth. 
```{r read_in_seurat_object, fig.height=5, fig.width=6}
pbmc <- readRDS(file = "/brahms/shared/PASTA/pbmc.rds")
projected.umap <- readRDS('/brahms/shared/PASTA/umap_pbmcs.Rds')
pbmc <- pbmc[, Cells(projected.umap)]
pbmc[['umap']] <- projected.umap
predictions <- read.delim('/brahms/shared/PASTA/azimuth_pred_pbmcs.tsv', row.names = 1)
pbmc <- AddMetaData(
  object = pbmc,
  metadata = predictions)
DimPlot(pbmc, group.by = 'predicted.celltype.l2', label = T) + NoLegend()
```

## Make polyA assay
Next, read in polyA counts and make a polyA site assay.
```{r load_polyA, message=FALSE}
pA.count.file <- "/brahms/shared/PASTA/pA_counts.tab.gz"
peak.file <- "/brahms/shared/PASTA/pA_polyA_peaks.gff"
fragment.file <- "/brahms/shared/PASTA/10k_PBMC.mod.blocks.sort.uniq.bed.gz"

pA.counts = ReadPolyApipe( counts.file = pA.count.file, 
                           peaks.file = peak.file, 
                           filter.chromosomes = TRUE,
                           min.features = 10, 
                           min.cells = 25)

#add gemgroup information to match cellranger output
colnames(pA.counts) <- paste0( colnames(pA.counts), '-1')

# create polyAsite.Assay
pA.assay = CreatePolyAsiteAssay(counts = pA.counts , genome = "hg38", fragments = fragment.file, validate.fragments = FALSE)
```

## Add polyA site assay to seurat object
```{r add_polyA_assay}
# intersect cells between polyA assay and RNA assay 
cells = intersect( Cells(pbmc) , Cells(pA.assay))
length(cells)
pbmc = subset(pbmc, cells = cells)
pA.assay = subset(pA.assay, cells = cells)
pbmc[['pA']] <- pA.assay
```

## Annotate peaks 
This is currently not working.
```{r annotate, eval=FALSE}
# Annotate from EnsDB is done similarly to polyApipe
# In addition, we annotate tandem UTRs
gtf.file = '/brahms/shared/PASTA/ensembl_hg38_v97.gtf'
BSgenome <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38

pbmc = AnnotatePASfromGTF(object = pbmc, assay = "pA", 
                           transcriptDetails = TRUE, SequenceAnalysis = FALSE, PAS_Types = FALSE,
                           genome = BSgenome, gtf.file = gtf.file,
                           pA_motif_max_position = 60, AAA_motif_min_position = 10,
                           polystretch_length = 10, max_mismatch = 1, 
                           hard_extension = 10, extension = 2000 )
```

## Calculate polyA site residuals
```{r residuals, warning=FALSE}
#set meta features 
meta.features = readRDS(file="/brahms/shared/PASTA/pbmc_meta_features_new.Rds")
pbmc[['pA']]@meta.features <- meta.features

#use all features that are annotated to a gene and are in 3'UTR or extension
features.use <- rownames(meta.features)[meta.features$symbol!="" & 
                                        meta.features$UTR3 |  
                                        meta.features$UTR3_extension ]
length(features.use) #6122 features within 3'UTR or extension

start_time <- Sys.time()
pbmc = CalcPolyAResiduals(object = pbmc,
                          assay="pA",
                          features=features.use,
                          min.counts.background = 5, 
                          min.variance = 0.1, #minimum variance of 0.1 at each site 
                          do.center = TRUE, #return the centered polyA residuals
                          verbose=TRUE )
end_time <- Sys.time()
print(paste0(round(end_time - start_time, 2), " seconds elapsed"))

dim(GetAssayData(pbmc, slot="data")) #number of features in polyA site assay
dim(GetAssayData(pbmc, slot="scale.data")) #number of features to calculate residuals
```

## Run PCA and UMAP on variable features 
```{r polyA_analysis, fig.height=4, fig.width=7, message=FALSE}
pbmc <- FindVariableFeatures(pbmc)
pbmc <- RunPCA(pbmc)
pbmc <- RunUMAP(pbmc, dims = 1:20)
Idents(pbmc) <- pbmc$predicted.celltype.l2
DimPlot(pbmc, group.by="predicted.celltype.l2")
```

## Loci with APA
Monocytes appear to differ in their polyA site usage from other cells. To investigate this further, we 
test how the residuals differ between monocytes and all other cells.
```{r find_markers}
mono.markers <- FindMarkers(pbmc, 
                            slot = "scale.data",  #use the scale.data slot to test residuals
                            ident.1 = c("CD14 Mono", "CD16 Mono"),
                            min.pct = 0.05)
mono.markers$symbol <- pbmc[['pA']][["symbol"]][rownames(mono.markers),]    
# to do: have FindMarkers return gene name as well
head(mono.markers, 15)
```

## Visualization
We can use coverage plots to illustrate differences between monocytes and other celltypes.
```{r coverageplot, fig.height=7, fig.width=9, message=FALSE}
#add annotation to polyA assay
library(EnsDb.Hsapiens.v86)
gene.ranges <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) # convert EnsDb to GRanges
seqlevelsStyle(gene.ranges) <- 'UCSC'
genome(gene.ranges) <- "hg38"
Annotation(pbmc[["pA"]]) <- gene.ranges
CoveragePlot(pbmc, "chr17-41690699-41691644", extend.upstream = 200, extend.downstream = 200, 
             idents = c("CD14 Mono", "CD8 Naive", "CD4 TCM", "CD4 Naive"), annotation="transcript")
```


## Visualize average 3'UTR length and tandem APA sites

```{r tandem_apa, fig.height=4, fig.width=5}
pbmc <- CalcAvgTandemUTRlength(pbmc, assay="pA") 
VlnPlot(pbmc, features = "tandem.UTR.lengths.norm", group.by = "predicted.celltype.l2", 
        pt.size = .1, sort=TRUE) + NoLegend() 
FeaturePlot(pbmc, features = "tandem.UTR.lengths.norm" , min.cutoff = "q5", max.cutoff = "q95" ) + ggplot2::scale_color_distiller(palette = "Spectral")
```


