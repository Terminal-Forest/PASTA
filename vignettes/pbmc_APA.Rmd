---
title: "Using PASTA for Analyzing alternative polyadenylation in PBMCs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Using PASTA for Analyzing APA in PBMCs}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE)
```

```{r setup}
#remotes::install_github(repo = "satijalab/PASTA")
devtools::load_all()
library(PASTA)
```

## Annotate Cells using RNA.
First, you can quantify RNA and create a seurat object. Then, annotate cells by mapping to azimuth. 
```{r read_in_seurat_object, fig.height=6, fig.width=8}
pbmc <- readRDS(file = "/brahms/shared/PASTA/pbmc.rds")
projected.umap <- readRDS('/brahms/shared/PASTA/umap_pbmcs.Rds')
pbmc <- pbmc[, Cells(projected.umap)]
pbmc[['umap']] <- projected.umap
predictions <- read.delim('/brahms/shared/PASTA/azimuth_pred_pbmcs.tsv', row.names = 1)
pbmc <- AddMetaData(
  object = pbmc,
  metadata = predictions)
DimPlot(pbmc, group.by = 'predicted.celltype.l2', label = T) + NoLegend()
```

## Make polyA assay
Next, read in polyA counts and make a polyA site assay.
```{r load_polyA, message=FALSE}
pA.count.file <- "/brahms/shared/PASTA/pA_counts.tab.gz"
peak.file <- "/brahms/shared/PASTA/pA_polyA_peaks.gff"
fragment.file <- "/brahms/shared/PASTA/10k_PBMC.mod.blocks.sort.uniq.bed.gz"

pA.counts = ReadPolyApipe( counts.file = pA.count.file, 
                           peaks.file = peak.file, 
                           filter.chromosomes = TRUE,
                           min.features = 10, 
                           min.cells = 25)

#add gemgroup information to match cellranger output
colnames(pA.counts) <- paste0( colnames(pA.counts), '-1')

# create polyAsite.Assay
pA.assay = CreatePolyAsiteAssay(counts = pA.counts , genome = "hg38", fragments = fragment.file, validate.fragments = FALSE)
```

## Add polyA site assay to seurat object
```{r}
# intersect cells between polyA assay and RNA assay 
cells = intersect( Cells(pbmc) , Cells(pA.assay))
pbmc = subset(pbmc, cells = cells)
pA.assay = subset(pA.assay, cells = cells)
pbmc[['pA']] <- pA.assay
```

## Annotate peaks 
This is currently not working.
```{r annotate, eval=FALSE}
# Annotate from EnsDB is done similarly to polyApipe
# In addition, we annotate tandem UTRs
gtf.file = '/brahms/shared/PASTA/ensembl_hg38_v97.gtf'
BSgenome <- BSgenome.Hsapiens.UCSC.hg38::BSgenome.Hsapiens.UCSC.hg38

pbmc = AnnotatePASfromGTF(object = pbmc, assay = "pA", 
                           transcriptDetails = TRUE, SequenceAnalysis = FALSE, PAS_Types = FALSE,
                           genome = BSgenome, gtf.file = gtf.file,
                           pA_motif_max_position = 60, AAA_motif_min_position = 10,
                           polystretch_length = 10, max_mismatch = 1, 
                           hard_extension = 10, extension = 2000 )
```

## Calculate polyA site residuals
```{r residuals, warning=FALSE}
#set meta features 
meta.features = readRDS(file="/brahms/shared/PASTA/pbmc_meta_features.Rds")
pbmc[['pA']]@meta.features <- meta.features

#use all features that are annotated to a gene and are in 3'UTR or extension
features.use <- rownames(meta.features)[meta.features$symbol!="" & 
                                        meta.features$UTR3=="YES" | 
                                        meta.features$UTR3_extension=="YES"]


pbmc = CalcPolyAResiduals(object = pbmc,
                          assay="pA",
                          new.assay.name = "polyAresiduals",
                          features=features.use,
                          min.counts.background = 5, 
                          min.variance = 0.1, #minimum variance of 0.1 at each site 
                          do.center = TRUE, #return the centered polyA residuals
                          verbose=TRUE )
```

## Run PCA and UMAP on variable features 
```{r polyA_analysis, fig.height=6, fig.width=10}
pbmc <- FindVariableFeatures(pbmc)
pbmc <- RunPCA(pbmc)
pbmc <- RunUMAP(pbmc, dims = 1:20)
Idents(pbmc) <- pbmc$predicted.celltype.l2
DimPlot(pbmc, group.by="predicted.celltype.l2")
```

## Find markers that differentiate monocytes from other celltypes.
```{r find_markers}

mono.markers <- FindMarkers(pbmc, 
                            slot = "scale.data",  #use the scale.data slot to test residuals
                            ident.1 = c("CD14 Mono", "CD16 Mono"),
                            min.pct = 0.05)
head(mono.markers)
mono.markers$symbol <- pbmc[['pA']][["symbol"]][rownames(mono.markers),]    
head(mono.markers, 15)
```

## Visualization
We can use coverage plots to illustrate differences between monocytes and other celltypes.

```{r coverageplot, fig.height=7, fig.width=9}
#add annotation
library(EnsDb.Hsapiens.v86)
gene.ranges <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) # convert EnsDb to GRanges
seqlevelsStyle(gene.ranges) <- 'UCSC'
genome(gene.ranges) <- "hg38"
Annotation(pbmc[["pA"]]) <- gene.ranges
CoveragePlot(pbmc, "chr17-41690699-41691644", extend.upstream = 200, extend.downstream = 200, 
             idents = c("CD14 Mono", "CD8 Naive", "CD4 TCM", "CD4 Naive"), annotation="transcript")
```

