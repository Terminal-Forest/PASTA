---
title: "Using PASTA for Analyzing alternative polyadenylation in PBMCs"
output:
  html_document:
    theme: united
    df_print: kable
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>", 
  warning = FALSE)
```

```{r setup}
#remotes::install_github(repo = "satijalab/PASTA")
#library(PASTA)
devtools::load_all()
```

## PBMC 10k Datasets 
We downloaded 10k human pbmcs available here: https://www.10xgenomics.com/resources/datasets/10k-human-pbmcs-3-v3-1-chromium-x-without-introns-3-1-high
For this analysis, you need the bam files to quantify polyA sites as well as the standard RNA counts matrix.

## Annotate Cells using RNA.
First, you can quantify RNA and create a seurat object. Then, annotate cells by mapping to azimuth. 
```{r read_in_seurat_object, fig.height=5, fig.width=6}
pbmc <- readRDS(file = "/brahms/shared/PASTA/pbmc.rds")
projected.umap <- readRDS('/brahms/shared/PASTA/umap_pbmcs.Rds')
pbmc <- pbmc[, Cells(projected.umap)]
pbmc[['umap']] <- projected.umap
predictions <- read.delim('/brahms/shared/PASTA/azimuth_pred_pbmcs.tsv', row.names = 1)
pbmc <- AddMetaData(
  object = pbmc,
  metadata = predictions)
DimPlot(pbmc, group.by = 'predicted.celltype.l2', label = T) + NoLegend()
```

## Make polyA assay
Next, read in polyA counts and make a polyA site assay.
```{r load_polyA, message=FALSE}
pA.count.file <- "/brahms/kowalskim/data/polyA/code/polyAdb_v3/pipeline/counts.tsv.gz"
#peak.file <- "/brahms/shared/PASTA/pA_polyA_peaks.gff"
fragment.file <- "/brahms/shared/PASTA/10k_PBMC.mod.blocks.sort.uniq.bed.gz"
pAdbv3.counts = ReadPolyApipe( counts.file = pA.count.file, 
                           filter.chromosomes = TRUE,
                           min.features = 10, 
                           min.cells = 25)

rownames(pAdbv3.counts) <- left_join(data.frame(PAS_ID= rownames(pAdbv3.counts)), polyAdb.filter, by ="PAS_ID")$peak
#hack for now to get around needing the peaks to be named differently 

#add gemgroup information to match cellranger output
colnames(pAdbv3.counts) <- paste0( colnames(pAdbv3.counts), '-1')

#use the meta.features from the previous example
polyAdb.filter$peak.signac <- paste0(polyAdb.filter$Chromosome, "-", 
                                     polyAdb.filter$Start_Position, "-", 
                                     polyAdb.filter$End_Position)


meta.features <- data.frame(dplyr::filter(polyAdb.filter, peak %in% rownames(pAdbv3.counts)))
rownames(meta.features) <- meta.features$peak.signac

# create polyAsite.Assay
pA.assay = CreatePolyAsiteAssay(counts = pAdbv3.counts , genome = "hg38", fragments = fragment.file, validate.fragments = FALSE)
```

## Add polyA site assay to seurat object
```{r add_polyA_assay}
# intersect cells between polyA assay and RNA assay 
cells = intersect( Cells(pbmc) , Cells(pA.assay))
length(cells)
pbmc = subset(pbmc, cells = cells)
pA.assay = subset(pA.assay, cells = cells)
pbmc[['pA']] <- pA.assay
pbmc[['pA']]@meta.features <- meta.features
```


## Calculate polyA site residuals
```{r residuals, warning=FALSE}
#set meta features 
start_time <- Sys.time()
pbmc = CalcPolyAResiduals(object = pbmc,
                          assay="pA",
                          gene.names = "Gene.Symbol",
                          min.counts.background = 5, 
                          min.variance = 0.1, #minimum variance of 0.1 at each site 
                          do.center = TRUE, #return the centered polyA residuals
                          verbose=TRUE )
end_time <- Sys.time()
print(paste0(round(end_time - start_time, 2), " seconds elapsed"))

dim(GetAssayData(pbmc, slot="data")) #number of features in polyA site assay
dim(GetAssayData(pbmc, slot="scale.data")) #number of features to calculate residuals
```

## Run PCA and UMAP on variable features 
```{r polyA_analysis, fig.height=4, fig.width=7, message=FALSE}
pbmc <- FindVariableFeatures(pbmc)
pbmc <- RunPCA(pbmc)
pbmc <- RunUMAP(pbmc, dims = 1:20)
Idents(pbmc) <- pbmc$predicted.celltype.l2
DimPlot(pbmc, group.by="predicted.celltype.l2")
```

## Loci with APA
Monocytes appear to differ in their polyA site usage from other cells. To investigate this further, we 
test how the residuals differ between monocytes and all other cells.
```{r find_markers}
mono.markers <- FindMarkers(pbmc, 
                            slot = "scale.data",  #use the scale.data slot to test residuals
                            ident.1 = c("CD14 Mono", "CD16 Mono"),
                            min.pct = 0.05)
mono.markers$symbol <- pbmc[['pA']][["symbol"]][rownames(mono.markers),]    
# to do: have FindMarkers return gene name as well
head(mono.markers, 15)
```

## Visualization
We can use coverage plots to illustrate differences between monocytes and other celltypes.
```{r coverageplot, fig.height=7, fig.width=9, message=FALSE}
#add annotation to polyA assay
library(EnsDb.Hsapiens.v86)
gene.ranges <- GetGRangesFromEnsDb(ensdb = EnsDb.Hsapiens.v86) # convert EnsDb to GRanges
seqlevelsStyle(gene.ranges) <- 'UCSC'
genome(gene.ranges) <- "hg38"
Annotation(pbmc[["pA"]]) <- gene.ranges
CoveragePlot(pbmc, "chr17-41690699-41691644", extend.upstream = 200, extend.downstream = 200, 
             idents = c("CD14 Mono", "CD8 Naive", "CD4 TCM", "CD4 Naive"), annotation="transcript")
```


## Visualize average 3'UTR length and tandem APA sites

```{r tandem_apa, fig.height=4, fig.width=5}
pbmc <- CalcAvgTandemUTRlength(pbmc, assay="pA") 
VlnPlot(pbmc, features = "tandem.UTR.lengths.norm", group.by = "predicted.celltype.l2", 
        pt.size = .1, sort=TRUE) + NoLegend() 
FeaturePlot(pbmc, features = "tandem.UTR.lengths.norm" , min.cutoff = "q5", max.cutoff = "q95" ) + ggplot2::scale_color_distiller(palette = "Spectral")