---
title: "Analyzing Alternative Polyadenylation in PBMCs"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Plasmablasts in Covid and Healthy Patients}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  tidy = TRUE,
  tidy.opts = list(width.cutoff = 95),
  message = FALSE,
  warning = FALSE,
  time_it = TRUE, 
  error=TRUE
)
```


```{r packages}
#remotes::install_git("satijalab/PASTA", "develop") #install from github to have latest version
#library(PASTA)
devtools::load_all()
library(ggplot2)

```

## Annotate Cells Using RNA
First, we read in a seurat object with quantified RNA. We cannotated PBMCs
using our azimuth reference, as shown below. 
```{r read_rna,  fig.height=5, fig.width=7}
#currently reading in RNA annotations
#do we want to read in bam files and annotations just the seurat object?
obj <- readRDS(file="/brahms/kowalskim/data/polyA/data/workflow_12_04/plasmablasts/covid_rna_seurat_obj.Rds")
Idents(obj) <- obj$celltype.l1

library(RColorBrewer)
cols <- colorRampPalette(brewer.pal(8, "Dark2"))(30)
cols <- cols[c(1:4, 9, 11, 25:26, 30)]
names(cols) <-c("NK", "CD4 T", "CD8 T", "Other T", "B", "Plasma", "Mono", "DC", "Other")

DimPlot(obj, reduction="ref.umap", label=TRUE, cols = cols )
```

## Make polyA assay
Next, we read in polyA counts and make a polyA site assay.This requires 3 files:
a count, a peak file, and a fragment file (for visualization).
```{r load_polyA}
dir <- "/brahms/kowalskim/data/polyA/data/Science2020_Arunalacham/"
counts.file <- paste0(dir, "all_donors_pA_counts.tab.gz")
peak.file <- paste0(dir, "PAS_polyA_peaks.gff")
fragment.file = paste0(dir, "COVID.mod.uniq.blocks.sort.bed.gz")

polyA.counts = ReadPolyApipe( counts.file = counts.file, 
                             peaks.file = peak.file, 
                             filter.chromosomes = TRUE,
                             min.features = 10, 
                             min.cells = 25)
polyA.assay = CreatePolyAsiteAssay(counts = polyA.counts , genome = "hg38", fragments = fragment.file, 
                                   validate.fragments = TRUE)

```


## Add polyA assay to seurat object 
Here, we only use cells for which we have quantified RNA and polyA features. 
This gives us 52,142 cells for which we have both RNA and polyA information.
```{r add_polyA_assay}
cells = intersect(colnames(obj), colnames(polyA.assay))
obj = subset(obj, cells = cells)
obj[['polyA']] <- polyA.assay #add polyA assay to Seurat object 
DefaultAssay(obj) <- "polyA"
obj 
```


## Annotate polyA sites according to polyAdbv3.
To analyze polyA site usage, we must first annotate these sites and assign them to a gene. 
To do this, we leverage the polyAdbv3 resource. We take all of polyA sites that 
fall within 50 nucelotides of a polyAdbv3 polyA site and assign them a gene annotation and 
location within a transcript (intron vs last exon, etc.).

If we now view the meta features, we can see that features have have been assigned
to a gene (the column Gene_Symbol) if they 
lie within 50 nucleotides of a polyAdbv3 polyA site. 

If a feature has NA for gene symbol, this feature did not fall within 50 nucleotides 
of a polyAdbv3 site. 

```{r polyAdbv3_overlap}
polyAdb.file <- "/brahms/kowalskim/data/polyA/data/Science2020_Arunalacham/human_PAS_hg38.txt"
obj <- GetPolyADbAnnotation(obj, 
  assay = "polyA",
  polyAdb.file = polyAdb.file,
  max.dist = 50)
meta <- obj[['polyA']][[]]
head(meta)
```
## Calculating polyA residuals 
Now, we calculate polyA residuals on the basis of all polyA sites that fall within the last exon.  
We use 14,985 features in the last exon to run on polyA residuals

```{r calc_polyA_residuals}
features.last.exon = rownames(subset(meta, Intron.exon_location == "3'_most_exon"))
length(features.last.exon) 

obj <- CalcPolyAResiduals(obj, 
  assay = "polyA",
  features = features.last.exon,
  gene.names = "Gene_Symbol",
  verbose=TRUE)
```


## Perform dimension reduction on polyA residuals 
Now, we can run dimension reduction directly on the polyA residuals. We use 
`FindVariableFeatures` with `method = residuals` to find polyA sites that vary 
across cells, and then run perform dimension reduction on the variable polyA sites. 
We see that there is a very strong separation between Plasma cell and other celltypes.
```{r dim_reduc, fig.height=5, fig.width=7}
obj <- FindVariableFeatures(obj, selection.method = "residuals", 
                            gene.names="Gene_Symbol")
obj <- RunPCA(obj)
obj <- RunUMAP(obj, dims = 1:30, reduction.name = "polyA.umap", reduction.key = "polyAUMAP_")
DimPlot(obj, group.by="celltype.l1", reduction = "polyA.umap", cols = cols)
```

## Identify markers that change between B cells and Plasma cells. 
Ignore this for now :) 


## Visualize genes that change polyA site usage
We can also visualize genes where relative polyA site usage changes, such as below.

```{r gene_examples,  fig.height=7, fig.width=7}
Idents(obj) <- obj$celltype.l1
PolyACoveragePlot(obj, gene = "ARF4", gene.names = "Gene_Symbol") & 
  scale_fill_manual(values = cols)
```



